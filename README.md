# Архитектура компьютера, 3 лабораторная
## Лузин Борис Евгеньевич P3207

Вариант: lisp -> asm | acc | harv | hw | tick -> instr | struct | stream | port | cstr | prob2 | cache

Базовый вариант: **lisp** | acc | harv | hw | **tick** | struct | stream | port | cstr | prob2 | cache

## Язык программирования - Lisp 
### Синтаксис языка
```ebnf
digit := '0' | '1' | '2' | ... | '9'
letter := 'a' | 'b' | 'c' | ... 'z'
number := '-'? digit*
string := <any symbol except a \0>
name := letter* | digit*
expression := 
    number | 
    string |
    name | 
    operation |
    '( ' expression* ' )'
```
### Пример кода
Программы пишутся в виде s-выражений. В рамках эксперимента, было принято решение:
запись выражений осуществляется строго через пробел от каждой сущности/скобочки.
Это позволило заметно упростить для меня написание транслятора.
```lisp
( var a 0 ) ( var b 1 ) ( var bound 400000 )
( while ( < b bound ) (
( if ( = 0 ( % b 2 ) ) ( + ( print b ) ( print _\0 ) ) ( + 0 0 ) )
( var tmp b )
( var b ( + a b ) )
( var a tmp ) ) );
```
Некоторые специальные формы, существующие в языке: \
(Больше информации можно получить, изучив тесты в папочке tests)
+ `var` - объявляет переменную, возвращает статус 1 при успехе
```text
( var name value )
```

+ `var_input` - объявляет переменную буфером value, полученную из flow_buffer, возвращает статус 1 при успехе
```text
( var_input value name ( flow_buffer ) )
```
+ `print` - подает на порт вывода строку или примитив, возвращает статус 1 при успехе
```text
( print value | variable | expression )
```
+ `while` - цикл типа do-while, сначала выполняется тело, после чего проверка, возвращает статус 1
```text
( while ( expression ) ( ( expression1 ) ( expression2 ) ... ) )
```
+ `read` - записывает в предварительно аллоцированную память поток ввода. Требует явного использования
var_input для аллокации.
```text
( var_input value name ( read ) )
```
+ `lisp_read` - в качестве эксперимента (цель лабы) написал реализацию на своём языке. 
Оставил обе, для наглядности разницы. Аналогична read, но писать было проще.
var_input для аллокации.
```text
( var_input value name ( lisp_read ) )
```
+ `if`, `мат операции для варианта` - повторяют логику их Lisp

## Организация памяти

Память организвана согласно Гарвардской модели, где память данных и инструкций не едины.

- Машинное слово – не определено. Реализуется высокоуровневой структурой данных.

- Доступен только аккумулятор

- Запись и Чтение из памяти осуществляется отдельными командами(load и store)

## Система команд

### Инструкции

#### Формат машинных инструкций
Все инструкции представлены в виде высокоуровневых структур:
```text
{"opcode": COMMAND_NAME, "addr_mod": ADDR_TYPE, "addr": VALUE, "term": TERM, OPTIONAL["comment": SOME USEFUL INFO]}
```
- Тип адресации - \
```nep_addr``` - непосредственная адресация \
```abs_addr``` - абсолютная адресация \
```tos_addr``` - стековая адресация \
```non_addr``` - адрес не требуется \
```con_tos_addr``` - косвенная стековая адресация

#### Инструкции для работы с памятью
`load` - Загрузить значение по адресу типа ADDR_TYPE со значением VALUE в аккумулятор.

`store` - Загрузить значение аккумулятора по адресу типа ADDR_TYPE со значением VALUE в память.

#### Инструкции ветвления
`jump` - Безусловный переход по адресу типа ADDR_TYPE со значением VALUE

`jump_if_zero` - Безусловный переход по адресу типа ADDR_TYPE со значением VALUE если выставлен флаг **Z**

`jump_if_not_zero` - Безусловный переход по адресу типа ADDR_TYPE со значением VALUE если не выставлен флаг **Z**

`jump_if_neg` - Безусловный переход по адресу типа ADDR_TYPE со значением VALUE если выставлен флаг **N**

`jump_if_not_neg` - Безусловный переход по адресу типа ADDR_TYPE со значением VALUE если не выставлен флаг **N**

#### Арифметические операции (минимальное надмножество для решения задачи)
`increment` - инкремент аккумулятора

`decrement` - декремент аккумулятора

`add` - Сложение аккумулятора со значением по адресу типа ADDR_TYPE со значением VALUE

`sub` - Вычитание аккумулятора со значением по адресу типа ADDR_TYPE со значением VALUE 

`mod` - Взятие модуля от аккумулятора со значением по адресу типа ADDR_TYPE со значением VALUE

#### Операции со стеком
`push` - Положить на стек значение аккумулятора 

`pop` - Снять со стека значение и положить в аккумулятор

`clean_head` - Снять со стека значение и положить в аккумулятор, уменьшив указатель стека на 2

#### Операции ввода-вывода
`in` - Считать данные с внешнего устройства в регистр аккумулятор

`out` - Отправить значение аккумулятора на внешнее устройство

#### Остальные операции
`halt` - Остановка процессора

## Транслятор
Интерфейс командной строки: `python translator.py <input_file> <target_file>`

Трансляция происходит в 2 этапа:
- Парсинг текста программы и преобразование его в дерево для поддержания любого уровня вложенности
- Генерация машинного кода для каждого листика, снизу вверх

## Модель процессора
Интерфейс командной строки: `python machine.py <code_file> <input_file>`

### Control Unit

### Datapath


#### Флаги
В результате выполнения операции АЛУ выставляет 2 флага:
- zero - результат операции равен нулю
- neg - результат операции отрицателен